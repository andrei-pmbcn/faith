/**
* @author Andrei Pambuccian
* @copyright 2021 Andrei Pambuccian
* @license {https://www.gnu.org/licenses/gpl-3.0.en.html|GPL3.0 license}
*/

import { Ruleset } from './ruleset.js';
import Side from './side.js';

/**
* @namespace Faith.Encounter
*/

//[TODO] Make sure tests exist for all entries in encounterConfig to
// ensure that they get properly loaded in the EncounterManager

/**
* The configuration object used when creating an encounter. Make sure
* charsSide1 and charsSide2 contain characters before passing this to the
* EncounterManager object's constructor.
* @typedef {object} Faith.Encounter.encounterConfig
*
* @property {Faith.Encounter.Ruleset} ruleset - the ruleset that the
* encounter uses
*
* @property {Faith.Encounter.Side} side1 - the full details of side1
*
* @property {Faith.Encounter.Side} side2 - the full details of side2
*
* @property {Faith.Encounter.Side} [neutral] - the full details of the
* neutral side
* 
* @property {Array.<String>} [classes=[]] - the encounter's HTML-style
* classes
*
* @property {string} [eventPrefix='Encounter-'] - The prefix to append to
* the start of the names of all events generated by the EncounterManager,
* to avoid polluting the global event namespace.
*
* @property {object.<number>} [props={}] - A list of extra numerical
* properties to be added to the social encounter, and their initial values
*
* @property {boolean} [raiseAlertOnErrors=true] - Whether alerts (modals)
* should be displayed when encountering an error during the social
* encounter
*
* @property {Array.<Faith.Encounter.Trait>} [traits=[]] - The list of the
* encounter's traits
*/
const encounterConfig = {
	side1: new Side(),
	side2: new Side(),
	neutral: new Side(true),
	classes: [],
	eventPrefix: '',
	props: {},
	ruleset: null,
	raiseAlertOnErrors: true,
	traits: [],
}

export encounterConfig;

/**
* The EncounterManager singleton class handles the logic of the entire
* encounter, applying effects to the various entities in the game
* (characters, boosters, arguments and traits), processing research and
* probing and carrying out commands.
*
* @memberof Faith.Encounter
*/
class EncounterManager {
	/**
	* Creates the EncounterManager.
	* 
	* @constuctor Faith.Encounter.EncounterManager
	* @param {Faith.Encounter.EncounterConfig} config - a config object
	* specifying all the parameters for creating the encounter; its
	* side1.chars and side2.chars arrays must each contain at least one
	* Character, and no character may belong to multiple sides.
	*/
	constructor(config) {
		if (!config) {
			this.raiseAlertOnErrors = true;
			this._throw('missing config object for the '
				+ 'EncounterManager\'s constructor');
			return;
		}

		/**
		* Whether the manager raises an alert on errors.
		*
		* @type {boolean}
		*/
	 	this.raiseAlertOnErrors = config.raiseAlertOnErrors ?? true;
		this.eventPrefix = config.eventPrefix ?? 'Encounter-';


		/**
		* The ruleset used by the encounter.
		*
		* @type {Faith.Encounter.Ruleset}
		*/
		if (config.ruleset && config.ruleset instanceof Ruleset) {
			this.ruleset = config.ruleset;
		} else {
			this._throw('invalid ruleset for the encounter')
		}

		/**
		* The three sides in the encounter. sides[0] is the neutral side,
		* sides[1] is side 1 and sides[2] is side 2.
		*
		* @type {Array.<Faith.Encounter.Side>}
		*/
		this.sides = [];
		this.sides[0] = config.neutral;
		this.sides[1] = config.side1;
		this.sides[2] = config.side2;

		if (!this.sides[1]) {
			this._throw('missing Side object of side1 in the '
				+ 'encounter\'s config object');
		}

		if (!this.sides[2]) {
			this._throw('missing Side object of side2 in the '
				+ 'encounter\'s config object');
		}


		if (!(Array.isArray(this.sides[1].chars)
				&& this.sides[1].chars.length > 0)) {
			this._throw('no characters specified for side 1; please '
				+ 'include a non-empty charsSide1 array in your '
				+ 'EncounterConfig object.');
		}

		if (!(Array.isArray(this.sides[2].chars)
				&& this.sides[2].chars.length > 0)) {
			this._throw('no characters specified for side 2; please '
				+ 'include a non-empty charsSide2 array in your '
				+ 'EncounterConfig object.');
		}

		if (this.sides ) //[TODO]


		this.props = config.props ?? {};
		this.traits = config.traits ?? [];
	}

	/**
	* The encounter's classes.
	*
	* @type {Array.<String>}
	*/
	this.classes = config.classes;

	/**
	* The index of the current turn, e.g. turn 1, turn 2 etc.
	*
	* @type {number}
	* @default 1
	*/
	currentTurn = 1;

	/**
	* A prefix string appended to the start of every event fired by the
	* event manager.
	*
	* @type {string}
	* @default 'Encounter-'
	*/
	eventPrefix = 'Encounter-';


	/**
	* The encounter's custom game-related properties
	* 
	* @type {object.<number>}
	* @default {}
	*/
	props = {};

	/**
	* The encounter's traits
	*
	* @type {Array.<Faith.Encounter.Trait>}
	* @default []
	*/
	traits = [];

	//[TODO] implement and test
	/**
	* Gets a given argument by their id number
	* 
	* @param {number} id - the id to be searched
	* @return {Argument} the argument returned
	*/
	getArgumentById(id) {

	}

	//[TODO] implement and test
	/**
	* Gets a given argument by their name; it is completely optional
	* for arguments to have names. If more than one name is found,
	* return an array of arguments.
	* 
	* @param {string} name - the name to be searched
	* @return {Argument|Array.Argument} the argument or arguments
	* returned
	*/
	getArgumentByName(name) {

	}

	//[TODO] implement and test
	/**
	* Gets a given character by their id number
	* 
	* @param {number} id - the id to be searched
	* @return {Character} the character returned
	*/
	getCharacterById(id) {

	}

	//[TODO] implement and test
	/**
	* Gets a given character by their name
	* 
	* @param {string} name - the name to be searched
	* @return {Character|Array.Character} the character returned
	*/
	getCharacterByName(name) {

	}

	//[TODO] implement and test
	/**
	* issues an order for a character to perform a given action.
	*
	* @param {Character} character - the character ordered to perform the
	* action
	* @param {Action} action - the action to be performed
	*/
	order(character, action) {


	}

	//[TODO] implement and test
	//[TODO] change the docs if using some other class than javascript
	// events
	/**
	* processes a single turn. Events will be fired by the EncounterManager
	* during this turn, and a list of these events, in the order of their
	* creation, will be returned, allowing the game's graphics and audio
	* to play through the turn after it has been computed.
	*
	* @return {Array} the array of the encounter's events
	*/
	runTurn() {
		
	}

	//[TODO] partially parse encounter XML files (NOT rulesets) into an
	// encounterConfig object
	static parse(encCfg, ruleset, id, ...args) {
		if (!encCfg) {
			encCfg = encounterConfig;
		}
		//[TODO]
		
		return encCfg;
	}

	/**
	* Throws an error and, if this.raiseAlertOnErrors is true, an alert 
	*
	* @access private
	*
	* @param {string} err - the error message
	*/
	_throw(err) {
		if (this.raiseAlertOnErrors === true) {
			alert('Error in social encounter manager: ' + err);
		}
		throw err;
	}
}

export EncounterManager;
