/**
* @author Andrei Pambuccian
* @copyright 2021 Andrei Pambuccian
* @license {https://www.gnu.org/licenses/gpl-3.0.en.html|GPL3.0 license}
*/

//[TODO] probing and visibility rules; refresh, allVisible (see readme)


import { Ruleset } from './ruleset.js';
import { Side } from './side.js';
import { List } from './list.js';

/**
* @namespace Faith.Encounter
*/

//[TODO] Make sure tests exist for all entries in encounterConfig to
// ensure that they get properly loaded in the EncounterManager

/**
* The encounter manager's configuration object.
*
* @typedef {object} Faith.Encounter.encounterConfig
*
* @property {string} [eventPrefix='Encounter-'] - The prefix to append to
* the start of the names of all events generated by the EncounterManager,
* to avoid polluting the global event namespace.
*
* @property {boolean} [raiseAlertOnErrors=true] - Whether alerts (modals)
* should be displayed when encountering an error during the social
* encounter
*/
const encounterConfig = {
	eventPrefix: 'Encounter-',
	raiseAlertOnErrors: true,
}

/**
* The EncounterManager singleton class handles the logic of the entire
* encounter, applying effects to the various entities in the game
* (characters, boosters, arguments and traits), processing research and
* probing and carrying out orders.
*
* @memberof Faith.Encounter
*/
class EncounterManager {
	/**
	* Creates the EncounterManager.
	* 
	* @constuctor Faith.Encounter.EncounterManager
	* @param {Faith.Encounter.Ruleset} ruleset - the social encounter
	* ruleset that describes all of the encounter's rules
	* @param {Faith.Encounter.EncounterConfig} [config={}] - the encounter
	* manager's settings
	*/
	constructor(ruleset, config) {
		/**
		* Whether the manager raises an alert on errors.
		*
		* @type {boolean}
		*/
	 	this.raiseAlertOnErrors = config.raiseAlertOnErrors ?? true;

		/**
		* A prefix string appended to the start of every event fired by the
		* event manager.
		*
		* @type {string}
		* @default 'Encounter-'
		*/
		this.eventPrefix = config.eventPrefix ?? 'Encounter-';

		/**
		* The encounter's classes.
		*
		* @type {Set.<String>}
		* @default Set([])
		*/
		this.classes = config.classes ?? new Set();

		/**
		* The ruleset used by the encounter.
		*
		* @type {Faith.Encounter.Ruleset}
		*/
		this.ruleset = ruleset;

		if (!this.ruleset || !this.ruleset instanceof Ruleset) {
			this._throw('invalid ruleset for the encounter.')
		}

		/**
		* The three sides in the encounter. sides[0] is the neutral side,
		* sides[1] is side 1 and sides[2] is side 2.
		*
		* @type {Array.<Faith.Encounter.Side>}
		*/
		this.sides = [];
		this.sides[0] = config.neutral;
		this.sides[1] = config.side1;
		this.sides[2] = config.side2;
	
		/**
		* The encounter's custom game-related properties
		* 
		* @type {object.<number>}
		* @default {}
		*/
		this.props = {};

		/**
		* The encounter's traits
		*
		* @type {Faith.Encounter.List.<Faith.Encounter.Trait>}
		* @default []
		*/
		this.traits = new List();
	}

	/**
	* The index of the current turn, e.g. turn 1, turn 2 etc.
	*
	* @type {number}
	* @default 1
	*/
	currentTurn = 1;

	/**
	* Adds an entity to the encounter
	*
	* @param {Faith.Encounter.Entity} entity - the entity to be added
	*
	* @return {Faith.Encounter.EncounterManager} the encounter manager
	* itself
	*/
	add(entity) {
		//[TODO] auto-assign id if id is null


	}


	/**
	* issues an order for a character to perform a given action.
	*
	* @param {Character} character - the character ordered to perform the
	* action
	* @param {Action} action - the action to be performed
	*/
	order(character, action) {
		//[TODO] implement and test


	}

	/**
	* Removes an entity from the encounter
	*
	* @param {Faith.Encounter.Entity} entity - the entity to be removed
	*
	* @return {Faith.Encounter.EncounterManager} the encounter manager
	* itself
	*/
	remove(entity) {
		//[TODO]
	}

	//[TODO] implement and test
	//[TODO] change the docs if using some other class than javascript
	// events
	/**
	* processes a single turn. Events will be fired by the EncounterManager
	* during this turn, and a list of these events, in the order of their
	* creation, will be returned, allowing the game's graphics and audio
	* to play through the turn after it has been computed.
	*
	* @return {Array} the array of the encounter's events
	*/
	runTurn() {
		//[TODO]
	}

	/**
	* parse an encounter XML string or XMLDocument
	*
	* @param {String|XMLDocument} source - the source of the XML data,
	* either a string containing the data or an actual XMLDocument.
	* @param {String} id - the id of the encounter to be parsed. If set
	* to null, it will parse the first encounter found in the source.
	* @param {String} fileName - an optional file name, shown in errors.
	*
	* @return {Faith.Encounter.EncounterManager} the manager itself.
	*/
	parse(source, id, fileName = null) {
		//[TODO]


	}

	validate() {
		//[TODO] ensure that each conflicting side has at least one
		// character

		//[TODO] validate the individual entities in the encounter

	}

	/**
	* Throws an error and, if this.raiseAlertOnErrors is true, an alert 
	*
	* @access private
	*
	* @param {string} err - the error message
	*/
	_throw(err) {
		if (this.raiseAlertOnErrors === true) {
			alert('Error in social encounter manager: ' + err);
		}
		throw err;
	}
}

export { encounterConfig, EncounterManager };
